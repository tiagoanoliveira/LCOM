Prev Top Next
2. What to Do?
Write in the C programming language several functions to use the PC's timer. The goal is to develop a generic module that will be used to create a library, which you will be able to use in the course's project.

In this lab we specify the prototype of functions that operate on the I/O device. However, for testing/evaluation purposes you will also have to develop a set of test functions, whose prototype we specify. In future labs, we will specify only the testing functions and you will have to design the functions for operating on the I/O device.

Specifically, you shall develop the following test functions:

int timer_test_read_config(uint8_t timer, enum timer_status_field field)
int timer_test_time_base(uint8_t timer, uint32_t freq)
int timer_test_int(uint8_t time)
These three functions are declared in header file lab2.h, and file lab2.c contains their implementation stubs. You may find it convenient to add your test code to these files; this way you will avoid making mistakes in their definition. Section 7 describes what these functions should do, and specifies the functions that you will have to develop to implement them. You can also read the documentation generated by doxygen for the lab2 module.

The lab2.c file, also includes the main() function. You should not change it, except possibly for the arguments of the calls of some functions, as explained in Section 6.

To initialize Git's working directory that you have created in the last lab you can do as follows:

Download the archive with the development files provided for this lab
Unzip that archive to the lab2/ directory of Git's working directory
Then add these files to your local Git repository
Finally, synchronize your local Git repository with your group's repository at GitLab@UP.
IMP.- For each group, only one member needs to perform these steps. The other members should just synchronize their local repository with the remote repository at GitLab@UP afterwards.

2.1 Class Preparation
This lab is planned to be carried out in two classes. The goals for each class are as follows:

First class
Implement both timer_test_read_config() and timer_test_time_base() and associated functions.
Second class
Implement timer_test_int() and associated functions in the second lab.
For the first class, you should read this handout at least until, including, Section 7, except Sections 4 and 5.2, which concern interrupts, the focus of the second class. In addition, you should read 1) the i8254 data sheet, especially the section on its programming interface (entitled "Operational Description"), and 2) the set of lecture slides that were shared in the Moodle page. Finally, you should also add the code provided to your group's repository at GitLab@UP, as described above.

For the second class, you should read Sections 4 and 5.2, as well as the material about interrupts that will be presented in the lectures and shared in the Moodle page. (Furthermore, if you have not completed the goals for the first class, you should complete them before the second class.)

Although we do not grade your use of Git, we encourage you to regularly commit your work as you implement and test the required functions. Remember that one of the goals of this course is that you learn how to use tools typically used in the development of large programs, including version control systems, and you will receive credit for it (in the project). Thus, it is a good idea to develop good habits as early as possible.

Prev Top Next

Prev Top Next
3. The PC's Timer, the i8254 IC
Every PC "has" an i8254 an integrated circuit (IC) with 3 timers, whose block diagram is shown in Figure 1. In this lab, you'll use timer 0 only. You must not change timer 1 configuration.


Figure 1: The PC's timer: i8254.
The 3 timers are identical and operate independently of one another. Thus we will describe only one timer.

A timer has a 16 bit counter, two input lines, Clock and Enable, and an output line Out. The Enable line is used to enable/disable the timer. When a timer is enabled, the value of its counter is decremented by one on every pulse of the Clock line. The value of Out depends on the counter's value and on the operating mode.

3.1 Operating Mode 3: Square wave generator
The i8254 supports several modes, but in this lab you will use only mode 3, square wave generator, because this is the mode Minix configures all timers. In this mode, the Out line is high initially and until the counter reaches half of its initial value. It then goes low until the counter reaches zero, at which time the counter is reloaded with its (pre-programmed) initial value, Out is set to high and the cycle begins again. Thus, in mode 3, the timer generates a square wave with a frequency given by the expression clock/div, where clock is the frequency of the Clock input and div is the value loaded initially in the timer.

3.2 Programming a Timer
Each timer has a 16 bit counter, which may be both read and written. Furthermore, the i8254 has a single control register that can be written only, and that is used to configure the operation of all timers.

Each timer is programmed independently of the other timers. Programming a timer requires two steps:

Specifying the timer operating mode, by writing a control word to the control register
Loading the counter initial value, by writing to the counter register.
The format of the control word (an 8-bit value) is shown in Table 1.

Bit	Value	Function
Select counter
7,6	00	0
01	1
10	2
Initialization Mode
5,4	01	LSB
10	MSB
11	LSB followed by MSB
Operating Mode
3,2,1	000	0
001	1
010	2
110*
011	3
111*
100	4
101	5
Counting base
0	0	Binary (16 bits)
1	BCD (4 decades)
Table 1: Format of the i8254 control word (byte).
*: For 'compatibility with future Intel products'.
Thus, bits 6 and 7 specify which timer to program. Bits 1, 2 and 3 specify the operating mode. Bit 0 specifies whether the counter is a binary or a BCD counter, i.e. whether the inital value should be interpreted as a binary or a BCD value. Bits 4 and 5 specify how the initial value is loaded. The following paragraph provides some more details regarding these bits.

Although the counters are 16 bits, the i8254 has only 8 data lines. Thus to load the initial value of a counter, the LSB and the MSB must be written separately. The i8254 allows loading either of these bytes, or both of them. In the latter case, the LSB must be loaded first. Which bytes of the counter will be loaded in the second step of the programming procedure of a timer is specified by bits 4 and 5.

3.3 Reading a Timer's Configuration
Reading a timer's configuration requires a special command: the Read-Back command. This command allows not only to read the programmed mode, but also the count value and the current state of the OUT line of the selected timer(s). Table 2 shows the format of the Read-Back command.

Bit	Value	Function
7,6	11	Read-Back Command
5		COUNT
0	Read counter value
4		STATUS
0	Read Programmed Mode
3		Select Counter 2
1	Yes
2		Select Counter 1
1	Yes
1		Select Counter 0
1	Yes
0	0	Reserved
Table 2: Format of the i8254 Read-Back command.
Like the Control word, the Read-Back command is also written to the control register. The value of bits 6 and 7, allow the i8254 distinguish between a control word and a read-back command.

Selection of the counters is now done with the help of a bit mask -- bits 1 to 3 --, thus allowing to retrieve information regarding several timers with a single command.

Likewise, selection of the data to read uses a bit mask -- bits 4 and 5,-- thus allowing to read either the count value or the programmed mode, or both. Note that these bits are active low, i.e. the associated action occurs only when their value is 0, not 1, hence the bar over their names.

In this lab, you need to read the configuration of only one timer at a time. Thus after writing the appropriate Read-Back command to the control register, the configuration can be obtained by reading from that timer. You can find further details on the operation of the Read-Back command on the corresponding Section on pg. 7 of the i8254 data sheet.

Table 3 shows the format of a timer's Status byte:

Bit	Function
7	Output
6	Null Count
5, 4	Type of Access
3,2,1	Programmed Mode
0	BCD
Table 3: Format of the i8254 Status byte.
That is, bits 0 to 5 contain the corresponding bits of the last control word affecting the operation of that timer.

Bit 7 contains the current value of the timer's OUT line. Finally, bit 6 is related to the reading of the counting value, and we do not provide further details. You can find them in the i8254 data sheet.

3.4 Use of the i8254 on the PC
The PC uses each timer for a different purpose. Nevertheless, all timers use the same clock signal with frequency 1193181 Hz.

Timer 0
Figure 1 also shows that the output of the timer 0 is directly connected to line IRQ0 of the PC's interrupt controller. It is usually programmed in mode 3, to generate a more or less stable time reference that can be used by the operating system to measure time with a resolution of a few milliseconds. In Section 4 we describe the interrupt mechanism used by the PC.

Addresses
The registers of the i8254, like those of most other PC's I/O devices, are mapped in the I/O address space of the PC's processor. The address of the control register (TIMER_CTRL) is 0x43, the address of timer 0 is 0x40 (TIMER_0) and the address of timer 2 is 0x42 (TIMER_2). Although the counters of these timers are 16 bit, all these registers are 8 bits, and access to the MSB and the LSB of each counter is done as described above in Section 3.2.

Timer 2
Note: This is for your information. It is not relevant for this lab.

As shown in Figure 1, the output of timer 2 is connected to the PC speaker, and is used to generate tones by generating a square wave of an audible frequency. For example, to generate a 1000 Hz tone, the timer must be programmed to operate in mode 3, with an initial value of 1193.

Furthermore, to enable the speaker, you must set to 1 both bits 0 and 1 of I/O port 0x61 (SPEAKER_CTRL) . As shown in Figure 1, bit 0 is connected to the GATE of Timer 2 and if low, it will disable the timer. In addition, the OUT line of timer 2 is not connected directly to the speaker, instead it is gated via a NAND, whose other input line comes from bit 1 of port 0x61. Thus, unless that bit is set to 1, the input to the speaker will always be high, and no tone will be generated.

Note: On most laptops, VBox does not emulate the speaker. Therefore, you will not be able to hear any tone, even if you correctly configure the Timer 2.

Prev Top Next

Prev Top Next
4. PC's Interrupt HW
Note: This section describes the PC's priority interrupt handling based on the i8259. Although current systems support a more advanced (and complex) mechanism (the Advanced Programmable Interrupt Controller (APIC)), it is still possible to use the older interface.

In the PC, all HW interrupts are processed using the i8259 IC, the priority interrupt controller (PIC). This IC has 8 interrupt request (IRQ) lines which are connected directly to I/O devices. These lines have an implicit priority: IRQ line 0 has the highest priority, next comes IRQ line 1, and so on until IRQ line 7. This means, that the PIC will forward an interrupt request to the processor, only if no interrupt with the same or higher priority is being processed. Furthermore, it is possible to mask each line independently: while an IRQ line is masked, the PIC will not forward any interrupt request on that line to the CPU.

The PC uses two PICs in cascade, as shown in Figure 2, with the INT line of the second one (the slave) connected to the IRQ line 2 of the first one (the master). This means that IRQ lines 0 and 1 of the master have higher priority than the IRQ lines of the slave PIC. However, all IRQ lines of the slave have higher priority than IRQ lines 3 to 7 of the master.


Note: If a bit of the interrupt mask is set, then the corresponding IRQ-line is disabled.
Figure 2: The PC HW interrupt mechanisms.
Figure 2 outlines the interrupt mechanism used in the PC. When an I/O device activates its interrupt request line, the PIC will activate the CPU's interrupt line, initiating an interrupt sequence. The CPU will respond by activating an interrupt acknowledgment line. When the PIC detects that this line is active, it will put an 8-bit value, which was previously programmed on the PIC, in the data bus. The processor then uses this 8-bit value as an index to a table (the Interrupt Descriptor Table) whose entries contain the addresses of interrupt service routines. The processor will then transfer control to the address of the entry corresponding to the 8-bit value received from the PIC, after saving the address of the instruction being executed and the flags register on the stack, and disable interrupts. As a result, the processor will execute the device's interrupt service routine, or interrupt handler, which is responsible for informing the PIC that it has "finished" handling the interrupt, and must terminate with instruction IRETD.

The sequence described in the previous paragraph, assumes that:

the interrupt request line is not masked on the PIC, and no interrupt with higher or equal priority is being processed, otherwise the PIC will postpone the execution of the interrupt sequence;
the interrupts are enabled on the processor, otherwise the processor will postpone execution of the interrupt sequence.
Because the PIC does not generate another interrupt for devices with the same or lower priority until it is informed that the current interrupt has already been handled, it is up to the interrupt handler (IH) to do it, by writing the EOI command (0x20) to the control register. If the interrupt originates on the slave PIC, the IH will need to issue the EOI command to both the slave and the master PICs. Table 4 shows the addresses of the PIC registers and Table 5 shows the IRQ lines and the interrupt vectors for common I/O devices of a PC.

PIC	Controller Register	Interrupt Mask Register
PIC1	0x20	0x21
PIC2	0xA0	0xA1
Table 4: PIC I/O ports.
PIC 1	PIC 2
IRQ	Device	Vector	IRQ	Device	Vector
0	Timer 0	0x08	8	Real Time Clock	0x70
1	Keyboard	0x09	9	Replace IRQ2	0x71
2	slave 8259	0x0A	10	Reserved	0x72
3	Serial device COM2	0x0B	11	Reserved	0x73
4	Serial device COM1	0x0C	12	Mouse	0x74
5	Reserved/Sound card	0x0D	13	Math coprocessor	0x75
6	Diskette	0x0E	14	Hard disk	0x76
7	Parallel port	0x0F	15	Reserved	0x77
Table 5: PC's I/O Devices IRQ lines and interrupt vectors.
If you want to learn more about the 8259, you can take a look at this Renesas' Application Note

An interrupt handler cannot take any arguments nor return any values. Furthermore, it must save all the registers that it uses and must terminate with the IRETD instruction, which resets the stack and the processor to its state at the time the interrupt occurred. Because, in the IA-32 architecture, interrupts are disabled while the interrupt handler executes, i.e. executes the IRETD instruction, the CPU will not handle interrupts while in the interrupt handler. Therefore an interrupt handler should be as short as possible.

Prev Top Next

Prev Top Next
5. Minix 3 Notes
5.1 I/O Ports Access
In this lab, you'll use only the C programming language. Because C does not provide any operators or standard functions that allow access to I/O ports, you'll have to use functions provided by Minix 3 instead.

Direct I/O port access is a very powerful capability that can be easily misused and that can interfere with the proper operation of the operating system and other processes. Thus, in Minix 3, I/O port access is a privileged operation, and is provided via the SYS_DEVIO kernel call, and several libsys.a functions, that hide the details of making a kernel call from the user-level programmer. For this lab, you may find useful the following functions:

#include <lcom/lcf.h>

int sys_inb(int port, u32_t *byte);
int sys_outb(int port, u32_t byte);
Rembember that kernel calls can be issued only by privileged processes.

5.2 Interrupt Handling
Interrupt handling with Minix 3 is somewhat unusual, because device drivers are user level processes. Indeed, to ensure that the interrupt handler of a device driver does not mess with the kernel, interrupt servicing is also done at the user level by the device driver.

To allow this, the Minix 3 (micro) kernel has a generic interrupt handler, which notifies a device driver when an interrupt it may have to service occurs. Although this might appear strange at first, the truth is that an interrupt handler does not take any arguments and does not return any value. Thus, a simple notification is all that is required from the kernel. Handling of the interrupt proper must be done by the device driver.

The major disadvantage of this approach is that the interrupt servicing latency may become too large for devices that are very fast, such as gigabit Ethernet cards.

Subscribing/Unsubscribing an Interrupt Notification
To support this model, Minix 3 provides also the SYS_IRQCTL kernel call, and several libsys.a functions, that hide the details of making a kernel call from the user-level programmer. For this lab, you may find useful the following functions:

#include <lcom/lcf.h>

int sys_irqsetpolicy(int irq_line, int policy, int *hook_id);
int sys_irqrmpolicy(int *hook_id);
int sys_irqenable(int *hook_id);
int sys_irqdisable(int *hook_id);
All these calls return OK on success and 3 other values on failure.

sys_irqsetpolicy(int irq_line, int policy, int *hook_id)
This function should be used to subscribe a notification on every interrupt in the input irq_line. The policy argument specifies whether or not the interrupt on that IRQ line should be automatically enabled by the generic interrupt handler, or whether the device driver interrupt handler will do it. Finally, the hook_id argument is used both for input to the call and output from the call. The caller should initialize it with a value that will be used in the interrupt notifications, as described below. The value returned by the call in this argument must be used in the other calls to specify the interrupt notification to operate on.
int sys_irqrmpolicy(int *hook_id);
This function unsubscribes a previous subscription of the interrupt notification associated with the specified hook_id (this is the value returned by sys_irqsetpolicy() in its hook_id argument)
int sys_irqenable(int *hook_id)
This function enables (unmasks) interrupts on the IRQ line associated with the specified hook_id (this is the value returned by sys_irqsetpolicy() in its hook_id argument). This may be convenient if the policy specified in the sys_irqsetpolicy() call does not enable interrupts automatically.
int sys_irqdisable(int *hook_id)
This function disables (masks) interrupts on the IRQ line associated with the specified hook_id (this is the value returned by sys_irqsetpolicy() in its hook_id argument).
Again, subscribing and unsubscribing interrupt notifications, and enabling and disabling interrupts are privileged operations, and can be issued by privileged processes only.

Receiving an Interrupt Notification
The Minix 3 generic interrupt handler uses the Minix 3 interprocess communication (IPC) mechanism to notify a subscriber of the occurrence of an interrupt. This IPC mechanism is essentially a mechanism for sending and receiving messages between processes. Interrupt notifications are a special kind of message supported by Minix 3 IPC.

As a consequence, in Minix 3 a device driver is an event driven service that receives and processes messages, either interrupt notifications from the kernel, or service requests (usually I/O operations) from other processes.

The program that you will have to develop in this lab, is not a standard device driver, in that it does not receive service requests from other processes, but only interrupt notifications from the kernel. Thus, your program should include a loop in which interrupt notifications are received and handled. In a standard Minix 3 device driver, this loop is endless. In this lab, you may want to terminate the loop after a few iterations, or on some event. The following code segment illustrates the general structure of the main loop and the Minix 3 functions that should be used.

 1: #include <lcom/lcf.h>
 2: 
 3: int ipc_status;
 4: message msg;
 5:
 6: while( 1 ) { /* You may want to use a different condition */
 7:    /* Get a request message. */
 8:    if ( (r = driver_receive(ANY, &msg, &ipc_status)) != 0 ) { 
 9:        printf("driver_receive failed with: %d", r);
10:        continue;
11:    }
12:    if (is_ipc_notify(ipc_status)) { /* received notification */
13:        switch (_ENDPOINT_P(msg.m_source)) {
14:            case HARDWARE: /* hardware interrupt notification */				
15:                if (msg.m_notify.interrupts & irq_set) { /* subscribed interrupt */
16:                    ...   /* process it */
17:                }
18:                break;
19:            default:
20:                break; /* no other notifications expected: do nothing */	
21:        }
22:    } else { /* received a standard message, not a notification */
23:        /* no standard messages expected: do nothing */
24:    }
25: }
Function driver_receive() in line 8, is a function provided by the libdrivers.a library. It should be used by device drivers to receive messages, including notifications, from the kernel or from other processes. The first argument specifies the sender of the messages we want to receive. The value ANY means that the driver accepts messages from any process. The second and third arguments are the addresses of variables of type message and int, which will be initialized, by the driver_receive() code, with the message received and IPC related status, respectively.

The macro is_ipc_notify() in line 12, returns true if the message received is a notification or false otherwise, i.e. if it is a standard message.

The member m_source of type message, used in line 13, contains the endpoint of the sender of the message. The endpoint is an "address" used by Minix 3 IPC to specify the communication endpoints, i.e. the source and destination of a message. The macro _ENDPOINT_P allows to extract the process identifier from a process's endpoint. The value HARDWARE, used in line 14, is a special process identifier value to indicate a HW interrupt notification.

Finally, m_notify.interrupts, in line 15, is a member of the payload of a message type used for interrupt notification. This is a 32-bit bitmask with the bits of pending subscribed interrupts set to 1. When a subscribed interrupt is pending, the kernel activates the bit whose number has been passed in the hook_id argument of the sys_irqsetpolicy() call that subscribed that interrupt. For example, if the value of hook_id passed to the kernel upon subscription of one interrupt was 2, then when that interrupt occurs, the generic interrupt handler will send a notification message to the device driver with bit 2 of the m_notify.interrupts member set to 1. This scheme allows the kernel to send a single message to notify a process of the occurrence of several interrupts on different IRQ lines.

Thus, irq_set, also in line 15, is a bit mask, and is used to find out which interrupt has occurred, in order to execute the appropriate interrupt handler.

In this lab, you will subscribe only one interrupt, and therefore you will need to test the occurrence of that interrupt, and process it in line 16.

In other labs, and in the project, you may have to subscribe more than one interrupt, and therefore upon a notification you should check which of the subscribed interrupts are pending, and process each one of them.

Prev Top Next

Prev Top Next
6. The LCOM Framework (LCF)
The LCOM Framework is a framework to help both the students and the staff of LCOM. It provides the following functionality:

Helper functions
Which make some general verifications, e.g. checking whether an argument of a Minix kernel call is a NULL pointer, and report any detected problem. The goal is to help you to find bugs that would be hard to find, without the helper functions or a debugger.
Test support
Which allows testing your code using some predefined black-box test cases. The goal is to help you to test your code.
Automatic grading
Which allows grading your code considering other aspects than its behavior, automatically. (This functionality is available to LCOM staff only and, this year, will be used only for grading the programming tests.)
Furthermore, the LCF allows you to save on files that you can configure:

A trace of relevant Minix calls
I.e. the sequence of relevant Minix calls, either kernel calls or library calls, and their arguments, performed by a process. The goal is to further help you in the development of your code.
The output of printf() calls
Again, the goal is to help you in the development of your code.
To use the LCF all you need to do is to call the function lcf_start(),which should take as arguments those of main(), i.e. both argc and argv. You should also call lcf_cleanup() before exiting:

#include <lcom/lcf.h>
	
int lcf_start(int argc, char *argv[]);
int lcf_cleanup();
Your programs may also call other LCF functions. E.g. the main() for Lab 2, which is provided in lab2.c, includes all the functions that you are expected to use (read the comments in this code snippet):

#include <lcom/lcf.h>

int main(int argc, char *argv[]) {
  // sets the language of LCF messages (can be either EN-US or PT-PT)
  lcf_set_language("EN-US");

  // enables to log function invocations that are being "wrapped" by LCF
  // [comment this out if you don't want/need/ it]
  lcf_trace_calls("/home/lcom/labs/trace.txt");

  // enables to save the output of printf function calls on a file
  // [comment this out if you don't want/need it]
  lcf_log_output("/home/lcom/labs/output.txt");

  // handles control over to LCF
  // [LCF handles command line arguments and invokes the right function]
  if (lcf_start(argc, argv))
    return 1;

  // LCF clean up tasks
  // [must be the last statement before return]
  lcf_cleanup();

  return 0;
}
Note that you need not process the command line arguments: they are handled in lcf_start(), and if you invoke lab2, with the appropriate arguments, it will call the selected test function. To learn how to invoke lab2, just invoke it without any arguments, as described in Section 11: it will print on the Minix console, i.e. the VBox terminal, a usage message, explaining how to invoke it.

In addition to call lcf_start() and lcf_cleanup(), the first line of all the source code files that you write should be as follows:

#include <lcom/lcf.h>
This is needed so that the LCF can perform its "magic".

Finally, the last requirement to be able to take advantage of the LCF is that you compile it with the liblcf.a as described in Section 9.

Prev Top Next

Prev Top Next
7. Functions' Specification
As stated above, one of the goals of this lab is to develop a generic module that will be used to create a library, which you will be able to use in the course's project. In this lab, we specify the API, but we want you to play a more active role in future labs: we want you to design an API, rather than just implementing one.

We'll use this lab to show you by example how you can develop a fairly general API, which can be used to operate on the timer/counter, and that you can use to implement the testing functions that you will use to test your code. In the next labs, we'll just specify the testing functions, it will be up to you to design the API for operating on the I/O devices.

7.1 timer_test_read_config()
IMP.- In this section we use the terms configuration and status almost interchangeably. The reason for this is that although the functions specified here deal with the configuration of a timer, that information is denoted status in the i8254 data sheet. Thus, whereas the name of the functions specified here have the string config (or conf), the data structures specified here have the string status (or st) in their name.

The purpose of this function, which is declared in lab2.h:

#include <lcom/lcf.h>

int timer_test_read_config(uint8_t timer, enum timer_status_field field)
is to test whether your code is able to read and to display the specified field of status/configuration of a timer. The first argurment, whose value must be one of 0, 1 and 2, specifies the timer. The second and last argument is the following enumerated type that specifies which field of the i8254 status word must be displayed:

#include <lcom/lcf.h>

enum timer_status_field {
	tsf_all,	/* Display status byte, in hexadecimal */
	tsf_initial,	/* Display the initialization mode, only */
	tsf_mode,	/* Display the counting mode, only */
	tsf_base	/* Display the counting base, only */
};
IMP.- The enum timer_status_field is defined in timer.h, but you need not include this file directly; it is indirectly included via <lcom/lcf.h>. You can also read timer_test_read_config()'s doxygen documentation.

The stub for timer_test_read_config() is already included in lab2.c. You should add your code to this file, because the definition of some functions, e.g.:

int(timer_test_read_config)(uint8_t timer, enum timer_status_field field) {
  /* To be completed by the students */
  printf("%s is not yet implemented!\n", __func__);

  return 1;
}
has some special features that are essential in LCOM:

The function name, timer_test_read_config in this example, appears between parenthesis
This is because the LCF needs to intercept the call of some relevant functions, and this is done by renaming the name of those functions. By including the name of some functions between parenthesis, we prevent the LCF from renaming these functions when it should not.
Although timer_test_read_config() is fairly simple, we will implement it in two steps: a function that reads the configuration/status of a timer and a function that prints the specified fields of a timer's configuration/status:

#include <lcom/lcf.h>

int timer_get_conf(uint8_t timer, uint8_t *st)
int timer_display_conf(uint8_t timer, uint8_t conf, enum timer_status_field field)
Both functions should be implemented in timer.c. Again, you should use the file timer.c, which includes stubs for these functions with the appropriate definition. The following paragraphs describe these functions. You can also read their doxygen documentation.

The timer_get_conf() function should read the configuration of a timer as described in Subsection 3.3. It needs not parse the value read from the status register. This function could have been designed as a C API to the Read-Back command, allowing to read the configuration of not only one timer, but also of several timers and also the counting values of those timers. However, we have decided not to do it because that functionality is seldom needed.

To implement this function you will need to call the sys_inb() kernel call described already in Subsection 5.2. Note that although you need to read only one byte, the second argument of sys_inb() must be the address of a uint32_t variable, i.e. a variable with 4 bytes. If you use the address of a uint8_t variable, your program may terminate abnormally, because it accesses a memory position at an invalid address (thus triggering a segmentation violation signal). To avoid this, you should implement the following auxiliary function:

#include <lcom/utils.h>
	
int util_sys_inb(int port, uint8_t *byte)
which is declared in utils.h, and call it instead of calling directly sys_inb(). For more details please check its doxygen documentation. The stub for util_sys_inb() is already provided in utils.c; you should add your code to this stub.

The timer_display_conf() function should parse the value passed in its second argument, conf, which is assumed to be the configuration of the timer specified in its first argument, timer, as returned by the read-back command. The third and last argument specifies which field of the i8254 status word must be displayed

To print in a human friendly way the configuration, timer_display_conf() must invoke the following function that we provide:

#include <lcom/lcf.h>

int timer_print_config(uint8_t timer, enum timer_status_field field, union timer_status_field_val conf)
Where the conf argument is a union that can store any of the configuration fields, and is defined in timer.h:

#include <lcom/lcf.h>

union timer_status_field_val {
	uint8_t byte;			/* The status byte */
	enum timer_init in_mode;	/* The initialization mode */
	uint8_t count_mode;		/* The counting mode: 0, 1,.., 5 */
	bool bcd;			/* The counting base, true if BCD */
};
where the in_mode member allows you to specify any of the possible initialization modes of the i8254, and its type is also defined in timer.h:

#include <lcom/lcf.h>

enum timer_init{
	INVAL_val, 		/* Invalid initialization mode */
	LSB_only,		/* Initialization only of the LSB */
	MSB_only,		/* Initialization only of the MSB */
	MSB_after_LSB		/* Initialization of LSB and MSB, in this order */
};
The timer_print_config() function will also allow us to automatically check that you parsed correctly the value read via the read-back command.

7.2 timer_test_time_base()
The purpose of this function:

#include <lcom/lcf.h>

int timer_test_time_base(uint8_t timer, uint32_t freq)
which is declared in lab2.h, is to test your code to configure the specified timer (one of 0, 1 and 2) to generate a time base with a given frequency in Hz.

You could easily implement this function by loading the appropriate value into the specified timer counter. However, we want you to develop a general function that can be reused, and timer_test_time_base() is not a good name. So, you shall implement the following function to change the frequency of any timer:

#include <lcom/lcf.h>
	
int timer_set_frequency(uint8_t timer, uint32_t freq)
Function timer_test_time_base() needs only to call timer_set_frequency() with the appropriate arguments. Function timer_set_frequency() should also be implemented in timer.c. (Again, you should use the file timer.c, which includes stubs with the definition of this function appropriate for its use with the LCF.) For more information about timer_set_frequency(), please read its doxygen documentation.

IMP: Make sure that you do not change the 4 least significant bits (i.e. the counting mode and BCD vs. binary couting) of the control world, because that may change the timer's operating mode. (This requires you to read the input timer configuration before you change it.)

IMP: So that the LCF can provide you more help, in case you make some mistake in the implementation of timer_set_frequency(), you should write the utility functions:

#include <lcom/utils.h>
	
int util_get_LSB(uint16_t val, uint8_t *lsb)
int util_get_MSB(uint16_t val, uint8_t *msb)
which are declared in utils.h. For more information about them, please read its doxygen documentation. The stubs for util_get_LSB() and util_get_MSB() are already provided in utils.c; you should add your code to these stubs.

Testing timer_test_time_base()
In addition to run the LCF's test cases, you can test this function as described next.

As mentioned in the previous section, Minix 3 uses Timer 0 as a time reference to maintain the time of the day and for implementing software timers (for measuring the duration of time intervals). Thus, when it starts up, it configures Timer 0 to generate interrupts at a fixed rate, by default 60 Hz. Then, on every Timer 0 interrupt, Minix 3 increments a counter variable, which it uses to measure the time -- it expects that counter to be incremented by 60 every second.

Thus, if, for example, timer_test_time_base() is invoked with arguments 0 and 30 (meaning 30 Hz), it should program Timer 0 to generate 30 interrupts every second rather than 60. As a result Minix's time of day will rapidly become late, as you'll be able to check by giving the command date:

minix$ date
in Minix and by comparing its output with that generated by running the same command in Linux, i.e. the host OS.

7.3 timer_test_int()
The purpose of this function is to test your code that handles interrupts generated by Timer 0. With that in mind, it should invoke once per second the timer_print_elapsed_time() function that we provide you, for a time interval whose duration, in seconds, is specified in timer_test_int()'s argument. The function timer_print_elapsed_time() will print a message with the elapsed time on the console. Remember that, Minix also redirects the standard output of a privileged process to the file /usr/log/messages. Thus, if you are on a terminal different from the console, you can still see these messages by giving the command:

$ tail -f /usr/log/messages
Again, you could implement the entire functionality required-- subscribing an interrupt, handling the interrupts and unsubscribing an interrupt -- inside timer_test_int(), by invoking the right Minix 3 kernel calls. Again, that would not be reusable. More interesting is to design functions that you can use later in the project:

void timer_int_handler()
int timer_subscribe_int(uint8_t *bit_no)
int timer_unsubscribe_int()
which should be implemented in a file named timer.c. (Again, you should use the file timer.c, which includes stubs whose definition is appropriate for use with the LCF.) The following paragraphs describe these functions. You can also read their doxygen documentation.

As stated above the main use for the periodic interrupt generated by Timer 0 is as a time reference that can be used to measure time. This requires incrementing a counter on every interrupt. Thus all timer_int_handler() needs to do is to increment a global counter variable. Therefore timer_int_handler() should not call timer_print_elapsed_time(): the latter is lab specific, its purpose is just to test your code.

The implementation of timer_subscribe_int() is straightforward. You must call the sys_irqsetpolicy() kernel call, which is described in the paragraph on interrupt subscription in Subsection 5.3 . The policy you should specify in sys_irqsetpolicy() is IRQ_REENABLE, so that the generic interrupt handler will acknowledge the interrupt, i.e. ouput the EOI command to the PIC, thus enabling further interrupts on the corresponding IRQ line. You need not call sys_irqenable(), because the current implementation of sys_irqsetpolicy() already enables the corresponding interrupt. timer_subscribe_int() must return, via its input argument, the value that it has passed to the kernel in the third argument of sys_irqsetpolicy().

The implementation of timer_unsusbscribe_int() is even simpler; you just need to call sys_irqrmpolicy(), which is described in the paragraph on interrupt subscription in Subsection 5.3

Although these functions can be reused to (un)subscribe Timer 0 interrupts, they cannot be used to (un)subscribe interrupts for other I/O devices. Although, we would like to be able to do that, it is a bit too early to devise a general API. It requires more experience with the use of interrupts on Minix 3, as well as the use of some C features that we have not talked about yet.

This also applies to the "interrupt loop", i.e. the loop for receiving an interrupt notification. Thus, for the time being, I suggest that the interrupt loop be included in timer_test_int().

Prev Top Next

Prev Top Next
8. Coding/Development
If you followed the instructions in Section 2, the files that we provided you for this lab should be in the lab2/ subdirectoriy of Git's working directory, which is also the folder shared between Minix and your host OS. Thus you can use your favourite text editor in the host OS to implement the functions specified in the previous section.

If your host OS is Windows, you should be aware that sometimes Minix's development tools have trouble with files created by some text editors on Windows. Often, you can configure these text editors not to use the offending characters, but how to do it is not always straightforward. If you choose to use a text editor on Windows, in spite of these warnings, I suggest you test them as soon as possible to avoid wasting your time.

Recall Lab0 instructions about your development environment if you haven't done so.

As stated in those notes, you should follow an incremental/gradual development approach. I.e. you should fully develop and test the functions, one at a time, rather than coding all the functions before compiling and testing them. E.g. you should code timer_get_conf() first, compile it, and test it by running it with the appropriate inputs. Once you are happy with the test results you should commit your changes to the Git repository. Only then should you start developing the next function. Actually, you might want to commit your changes not only at the end of development cycle of each function, but while you are coding and as you carry out the different tests. (This will save you from losing all your hard work, if for some reason you break Minix. This seldom happens, but better safe than sorry.)

Prev Top Next

Prev Top Next
9. Compilation
Privileged user processes that access hardware (HW) resources directly, must be compiled with special MINIX 3 libraries. The make utility can simplify this task. All you have to do, every time you need to compile your program, is to execute the following command as user lcom (assuming you are in /home/lcom/labs/lab2/):

$ make clean && make
It will automatically invoke the compiler and other binary tools required to generate your program, according to a set of rules defined in a special file called Makefile. The following is the contents of the Makefile you shall use in this lab:

# name of the program (Minix service)
PROG=lab2

# source code files to be compiled
SRCS = lab2.c timer.c utils.c

# additional compilation flags
# "-Wall -Wextra -Werror -I . -std=c11 -Wno-unused-parameter" are already set
CFLAGS += -pedantic

# list of library dependencies (for Lab 2, only LCF library)
DPADD += ${LIBLCF}
LDADD += -llcf

# include LCOM's makefile that does all the "heavy lifting"
.include <minix.lcom.mk> 

Because for later labs you will need to create your own Makefile, it is important that you understand the meaning of some variables. This makefile will compile a service with name lab2, i.e. the value of variable PROG, using source files lab2.c, timer.c and utils.c, specified in variable SRCS.

The CFLAGS variable allows you to specify the options (flags) used by the compiler. By using the += operator, this makefile adds option -pedantic, which tells the compiler to issue all the warnings required by ISO C, to the options that have already been specified. In LCOM, these are -Wall -Wextra -Werror -I . -std=c11 -Wno-unused-parameter, i.e. the compiler will treat all warnings as errors (-Werror), therefore you must fix them to compile your code.

Variable DPADD is used to specify additional dependencies, usually for libraries. In LCOM, you must specify the dependency on the LCF library, liblcf.a. The convention, as shown above, is to convert to upper case the library name and remove the extension, .a. Variable LDADD specifies additional loader objects (for linking). So, again, you must specify the LCF library, by replacing the lib prefix with -l and discarding the extension. Again, note that for these variables, we use the assignment operator +=, meaning that we are adding what is in the right hand side to the variable specified in the left hand side.

Finally, the last line includes another makefile file, minix.lcom.mk, which does most of the work. This makefile does not change throughout all the labs or even the project. All you need to do is to set the appropriate values for the variables described above.

The main feature of make is that it is able to compile only the source files that were changed since the last time your program was compiled, if the list of dependencies is set properly. Furthermore, when invoking make you can specify a target in order to select the action you want to execute. In LCOM, you can specify several targets as follows:

make
I.e. when you run make, without specifying a target, it builds your program/service (e.g., lab2), by compiling the source files that were modified since the last modification time of the current executable. (If there is no executable, make compiles all source files).
make depend
generates a set of dependencies files, one per source file. Each of these files includes the header files included, directly or indirectly, by the respective source file;
make clean
deletes all object files (*.o files) that were generated by the compilation process and the executable, but not the dependency files (*.d);
make cleandir
similar to make clean, but also deletes the set of dependencies files, i.e. files with the .d extension
Therefore, you should run make cleandir only when you want a clean build; e.g., it is useful when committing to the Git repository in order to avoid inadvertently adding any compilation output files. (Although you can prevent this by setting an appropriate .gitignore file in lab2/.)

Although running the make command is all you need once the list of dependencies is properly set, it is recommended that you run make depend && make to be sure that the list of dependencies is always up-to-date, even when you included/removed header files from source files.

Lastly, mainly for future lab assignments, you should be aware that you can set additional source paths (.e.g., my_folder), i.e. folders containing source files, as follows:


.PATH: ${.CURDIR}/my_folder

You can add as many .PATH lines as you need, but be aware that no two files can have the same name, even if they are located in different folders. You have been warned!

Prev Top Next

Prev Top Next
10. Running your Program
As already mentioned, the programs that you will write in LCOM are privileged programs and require special permissions to be executed. So that an ordinary user like lcom can execute them, you must use the lcom_run utility as follows:

minix$ lcom_run lab2 ["<list of space separated args>"]
Where the characters [ and ], delimit optional input. If this part is absent, lab2 will display information on usage of the program. If present, the <list of space separated args> will be handled as the list of command line arguments of a standard user program and passed as command line arguments to your program, i.e. to its main() function. The lcf_start() function takes care of command line argument parsing, and will automatically invoke the intended test function for you.

Prev Top Next

Prev Top
11. Testing with the LCF
The LCF has a testing mode that allows you to test your code, by adding the string "-t <test no.>" at the end of the command line (as printed in the usage help message when you run lab2 via lcom_run, without specifying any argument).

In test mode, the LCF checks if your program behaves as expected; in other words, if the output is provided when and as expected. Before exiting, the LCF prints a message with the result of the test, either "Test FAILED" or "Test succeeded".

Please note that in test mode, the trace and output log functionalities of the LCF are disabled. Nevertheless, you can still use printf() and check its output in the /var/log/messages file.

12.1 Testing timer_read_config() and timer_test_time_base()
The value of <test no.>, must be one of 0 to 3, for timer_test_read_config() and 0, for timer_test_time_base().

In test mode, for these functions, the LCF handles timer related operations directly, rather than passing them to Minix. Therefore timer internal configurations will not be changed, even when testing timer_test_time_base(). Essentially, in this mode, the LCF emulates the timers. Thus, upon exiting, after showing the test result, the LCF displays the initial configuration of the timer, i.e. the one that is returned by the LCF.

When <test no.> is different from 0, the LCF will behave deterministically. I.e., if your program is correct, calls to sys_inb() will always return the same value, and calls to sys_outb() will have the effect specified in the i8254 documentation on the LCF's timer emulated state. However, if your program is not correct, e.g. you read from a wrong port, sys_inb() will return random values, or, e.g. you write an incorrect read-back command, sys_outb() will have no effect (on the LCF's timer emulated state). This way, we try to emulate the seemingly random behavior of the i8254 when you do not access its timers correctly.

As a consequence, a test may succeed in some cases, even if your implementation is not correct. E.g., when printing only the "base" field (either Binary or BCD) in timer_test_read_config(), there is a 50% chance that the test will succeed, if your code is getting random values.

To gain more confidence on the correctness of your code, we recommend that you repeat the tests several times. For <test no.> values different from 0, if you get different values in repeated runs, this means that your code must have some bug; as we wrote above for these test cases the emulation is deterministic, unless your code is not correct.

The purpose of test number 0 is to allow you to more extensively test your code. However, for that, some calls to sys_inb() may return random values. Thus, it is likely that different executions of your program will lead to different behaviors. To help you debug when using test number 0, you can initialize the pseudo-random number generator used by the LCF, by adding the option -s when you run lcom_run. This way, although the emulated behavior of the i8254 will be unexpected, it will be repeatable: all you need is to use the same integer number. Nevertheless, we recommend that you use test number 0, only after you have exhaustively run all the other test cases.

12.2 Testing timer_test_int()
For testing timer_test_int(), the value of <test no.> must be either 0 or 1.

In test mode, for this function, the LCF just checks that your program invokes timer_print_elapsed_time() once every second for a time interval whose duration is specified in the command line argument of your program. Thus, it reports failure in one of two cases: 1) the number of invocations of timer_print_elapsed_time() is not the one expected; and 2) the time interval between consecutive invocations of timer_print_elapsed_time() is different from 1 second.

The LCF also uses timer 0 interrupts to measure time. Therefore, if you messed up with timer 0 configuration, e.g. you have changed its interrupt frequency via timer_test_time_base(), the temporal behavior that you observe may be different from what is expected, but, if your program would have behaved correctly if you had not messed up with timer 0 configuration, the LCF will still report success.

As for the other test functions, the LCF behaves deterministically for test no. 1. Actually, in this test it behaves in a passive way, observing only timer 0 interrupts and your calls of timer_print_elapsed_time().

For test no. 0, the LCF behaves randomly, in that it will generate spurious notifications, i.e. notifications different from timer 0 interrupts. If your code is not correct, these spurious interrupts may make your program behave incorrectly, and therefore it may fail because of any of the above mentioned reasons, even if it does not fail in test number 1.

12.3 Final remarks
Although we have made an effort to provide you code that works correctly, it is impossible to test all possible cases, i.e. all possible implementations of timer_test_read_config(), timer_test_time_base() and timer_test_int(). (When we write "possible implementations", we mean both correct and incorrect implementations.) Therefore, if you find some weird behavior, please let us know, by posting on Lab2's forum in Moodle, and by providing us as much information as possible, without disclosing your code.

We hope that the LCF will help you test better your code, and therefore learn more and get better grades.

Again, so that you gain more confidence on the correctness of your code, we recommend that you repeat the tests several times.

Prev Top

