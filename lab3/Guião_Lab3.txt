Prev Top Next
2. What to Do?
Write in C language several functions that use the PC keyboard low level interface. The key functionality to implement is:

Read and display the scancodes, both the make codes and the break codes, generated by the PC keyboard via interrupts and via polling;
Handle interrupts from more than one I/O device
In this lab you have to implement the following test functions:

int kbd_test_scan()
int kbd_test_poll()
int kbd_test_timed_scan(uint8_t idle)
These functions are declared in header file lab3.h, and source file lab3.c contains their implementation stubs. Section 5 describes what these functions should do.

2.1 Preparation for the first class
The goal for the first class is to implement:

int kbd_test_scan(), with the IH written in C
int kbd_test_poll()
Therefore, for the first class you should read:

the material presented in the lectures about the PC keyboard
this handout, except Section 5.3.
This is likely to take you about 2 hours.

If you'd like to complete the implementation of these 2 functions during the first lab class, you should spend additional time trying to implement the first function.

2.2 Preparation for the second class
The goal for the second class is to implement:

int kbd_test_timed_scan(uint8_t idle)
Therefore, for the second class you should:

read also Section 5.3 of this handout;
complete the implementation of the two functions planned for the first lab class, if you have not done it yet.
Prev Top Next

Prev Top Next
3. The PC Keyboard and its Controller
Whenever a user presses or releases one of its keys, the keyboard sends a scancode to the keyboard controller (KBC). The KBC puts that code in a register, and generates an interrupt, if configured to do so. It is then up to the interrupt handler to read the scancode from the KBC. Although the KBC is seldom used in polled mode, you will also read the scancodes using polling in this lab.

3.1 Scancodes
A key's scancode depends only on the position of that key in the keyboard. It is different from the ASCII code (or other common encoding) of the characters that labels it.

The conversion between the key's scancodes and the code of the character on that key is usually done by the operating system using a keymap. For example, by default, Minix 3 uses the US keyboard keymap. The Minix 3 image you are using in LCOM uses a Portuguese keymap. The advantage of this approach for keyboard manufacturers is clear: a key in a given position, always generates the same scandcode, independently of whether the keyboard uses the US layout or another layout.

The scancode generated when a key is pressed, the make code, is different from the scancode generated when that key is released, break code. Usually, the break code of a key differs from the make code of that key on the MSB: the MSB of a break code is set whereas the MSB of the make code is not. For example, the make code of the ESC key is 0x01 whereas its break code is 0x81.

Using different make and break codes provides a lot of flexibility. A keyboard generates always the same scancode when a key is pressed/released independently of, for example, the Shift key being pressed. It is up to the operating system to make the necessary mapping between the reception of the Shift make code and the reception of its break code.

Most PC's scancodes are one byte long, although some special keys have longer scancodes. Two-byte long scancodes usually use 0xE0 as their first byte. This prefix is used in both the make and the break codes. Therefore the difference between the make and the break codes of a key is in the MSB of the second byte of the scancode. Some keyboards have keys that generate even longer scancodes.

The set of scancodes that we have described is known as Set 1, which is the set of scancodes of the PC-XT. Another set of scancodes, known as Set 2, appeared with the PC-AT and is widely used. However, the KBC can be programmed to translate Set 2 scancodes, received from the keyboard, to Set 1 scancodes, so that the keyboard device drivers need know only about Set 1 scancodes. Minix 3 keyboard driver configures the KBC to translate Set 2 scancodes, thus, as long as you do not change the KBC configuration in that respect, your code needs to handle only Set 1 scancodes.

3.2 The i8042: The keyboard controller (KBC)
In modern PCs, the communication between the keyboard and the processor is mediated by an electronic component that provides the functionality of the i8042, the keyboard controller (KBC). The communication between the KBC and the keyboard (actually, a microcontroller embedded in the keyboard) is by means of a serial communication protocol that is not the object of this lab.

In this lab, you need only to interface with the "i8042", which was thoroughly described in the lectures. In addition to read the lecture notes, you may find it useful to read the 8042 functional description from the IBM Technical Reference Manual and the data sheet of an 8042-compatible IC.

Prev Top Next

Prev Top Next
4. Minix 3 Notes
4.1 Disabling the Default Interrupt Handler
When Minix 3 boots, its terminal driver configures the KBC and installs its own keyboard interrupt handler. This allows Minix to receive input from the keyboard of the PC (or virtual machine) on which it is running. On one hand this is great: you do not need to configure the KBC. On the other hand this raises an issue: how can your code read the scancodes? Indeed, when the user presses/releases a key, the KBC will generate an interrupt, and the KBC interrupt handler of the terminal driver will execute and read the scancode, and possibly echo a character in the terminal.

To address this issue, your "driver" should subscribe the KBC interrupts, as described in Section 5.3 of Lab 2. However, the subscription should specify not only the IRQ_REENABLE policy but also the IRQ_EXCLUSIVE policy. As a result, the standard Minix 3 KBC interrupt handler will not be notified of the occurrence of KBC interrupts, thus preventing it from interfering with your "driver".

Note that the keyboard's IRQ number is 1.

To ensure that you can use the Virtual Box's Minix 3 terminal once your program is done, it must cancel its subscription of the KBC interrupt before exiting, by calling the sys_irqrmpolicy() kernel call.

4.2 Measuring Time
Both the KBC and the keyboard may take some time to respond to a command. For example, IBM's specification of the i8042 requires the keyboard to respond to a command in 20 ms. Thus your "driver" should not expect to get a response immediately after issuing a command. Two simple approaches are to wait indefinitely, or to wait until the KBC reports a time-out. A more fault-tolerant approach is to give enough-time for the KBC or the keyboard to respond, retry a few times on time-out, and finally give up. Because these time intervals are in the order of tens of ms, the sleep() function is not useful. Indeed, sleep()'s resolution is one second, i.e. it is able to measure time intervals whose duration is a multiple of a second. Instead, you can use the function tickdelay() of Minix 3's libsys as follows:

// You need not include the following line: it is already included in  <lcom/lcf.h>
#include <minix/sysutil.h>

#define DELAY_US    20000

tickdelay(micros_to_ticks(DELAY_US));
This function is similar to sleep() in that it suspends execution of the process that calls it for the time interval specified in its argument. .

Prev Top Next

Prev Top Next
5. Test function's specification
So that you become familiar with the kind of functions that you will have to implement in the programming tests, we have specified the functions that you are required to implement in this lab in a similar style.

Rather than implement the required functionality directly in the functions specified below, you should design and implement functions that may be useful to interface with the keyboard in your integration project. I.e., design functions that read the scancodes sent by the keyboard and that may be of use to configure or to find the status of the keyboard. You should try to implement a layered solution as suggested in the lectures.

In the project, you will score points for the quality of the design of your functions. We will grade not only how you structure the required functionality in functions, but also how do you group these functions in compilation modules, i.e. in the source files.

IMP.-Your implementation must use the LCF. Therefore, all your C source code files must include the following line:

#include <lcom/lcf.h>
This should be the first header file to be included in all your C source code files. You can create other header files, e.g. with the definition of macros for the i8042, if you need.

You can find doxygen's documentation of the functions to develop, and of some other useful functions, here.

5.1 kbd_test_scan()
The purpose of this function is to test that your code is able to read the scancodes from the KBC using an interrupt handler (IH) written in C.

In its definition, this function's name must appear between parenthesis, as shown in lab3.c:

#include <lcom/lcf.h>
	
int (kbd_test_scan)() {
	/* To be completed */
}
kbd_test_scan() should first subscribe the KBC interrupts, as described in the previous section.

The IH to implement must be a function that takes no arguments and returns no value. The passing of data between the IH and the other functions of your implementation must be done via global variables. The name of the IH must be kbc_ih()

The IH should:

read the status register and check if there was some communications error;
to read the scancode byte from the output buffer;
as described in the lectures.

In its definition, the function name of the kbc_ih() function must appear between parenthesis, as shown:

#include <lcom/lcf.h>
	
void (kbc_ih)() {
    // to be completed
To follow a layered implementation, as suggested in the lectures, you should implement this function in a file different from lab3.c. This is like we have done in Lab 2, where timer.c had the functions that interface with the i8254.

Every time the IH receives a byte from the keyboard, kbd_test_scan() should try to assemble a scancode. If it succeeds it should print it on the console, by calling the following function that we provide you:

#include <lcom/lcf.h>
	
int kbd_print_scancode(bool make, uint8_t size, uint8_t bytes[])
where:

make
indicates whether this is a make or a break code
size
is the size of the scancode in bytes
bytes
is an array with the bytes of the scancode, in order, i.e. the first byte will be in the first element of the array, the second byte, if any, in the array's second element and so on
The output of this function will look like the following:

Makecode:  0x12
Breakcode: 0x92
Makecode:  0xeO 0x49
Breakcode: 0xe0 0xc9
The kbd_test_scan() function should return when the user releases the Esc key, whose break code is 0x81. Before returning, this function should:

Cancel the subscription of the KBC interrupt, for the reasons described in the previous section;
Print the number of sys_inb kernel calls, by calling the following function that we provide you:
#include <lcom/lcf.h>
	
int kbd_print_no_sysinb(uint32_t cnt);
where:

cnt
is the total count of sys_inb() kernel calls by your program.
Because of the LCF, to count the number of sys_inb() calls, you must use the approach based on a wrapper function, as described in the lecture notes.

5.2 kbd_test_poll()
The purpose of this function is to test that your code is able to read the scancodes from the KBC using polling, i.e. you cannot use interrupts.

In its definition, this function's name must appear between parenthesis. lab3.c already provides a stub for this function:

#include <lcom/lcf.h>
	
int (kbd_test_poll)() {
    /* To be completed */
}
Like kbd_test_scan(), kbd_test_poll() should read the scan codes sent by the keyboard and print them on the console, by calling function kbd_print_scancode(), already described in the previous section. Therefore, the output will look like the following:

Makecode: 0x01
Breakcode: 0x81
Likewise, kbd_test_poll() should exit when the user releases the Esc key, and print the number of sys_inb() kernel calls, by calling the function kbd_print_no_sysinb().

Can you explain the large difference between the numbers of sys_inb() kernel calls displayed by kbd_test_poll() and by kbd_test_scan()?

Before returning, kbd_test_poll() must enable interrupts, by writing an appropriate KBC command byte. If it does not do it, the KBC will not generate interrupts, and thus the keyboard will get stuck. This is because lcf_start() disables keyboard interrupts, before calling kbd_test_poll(), to prevent Minix's keyboard IH from stealing the scancodes from your program,.

If the keyboard gets stuck, you should not restart Minix's VM. Instead, you should fix your code and use a remote shell, i.e. ssh, to compile it and to run it. Indeed, lcf_start() resets the KBC to a proper state, even if kbd_test_poll() does not enable interrupts.

5.3 kbd_test_timed_scan(uint8_t idle)
The purpose of this function is to test whether your program is able to handle interrupts from more than one device.

Its definition must also appear between parenthesis and lab3.c already provides a stub for this function:

#include <lcom/lcf.h>
	
int (kbd_test_timed_scan)(uint8_t idle) {
    /* To be completed */
}
Essentially, this test program should be similar to kbd_test_scan() in that it should subscribe the keyboad interrupts and print in the console the scancodes received from the keyboard, by invoking kbd_print_scancode(). The difference is that in this function, your program should exit not only when the user releases the ESC key, but also if it does not receive a scancode for a number of seconds equal to its argument, idle.

To measure this time interval you must use the interrupts of the PC's Timer 0. Note that you need not change the configuration of PC's Timer 0, only subscribe its interrupts, as done in timer_test_int() of Lab 2.

Prev Top Next

Prev Top Next
6. Compiling and Running your Program
6.1 Compiling
To use make as in Lab 2, you need to create a file named Makefile in /home/lcom/labs/lab3/. You can copy the Makefile we provided you in Lab 2 and make the appropriate changes. (Make sure that you add this Makefile to your Git repository.) In addition, replace the line defining the CPPFLAGS variable with the following line:

CPPFLAGS += -pedantic -DLAB3
Once you have created the Makefile you can compile your project by issuing (assuming the current working directory is /home/lcom/labs/lab3/ ) either:

minix$ make clean && make
or

minix$ make depend && make
The first of these command lines removes all the files generated by all the compilation processses executed since the last execution of make clean. By doing this, you will not take advantage of the incremental compilation capability of the make utility. However, the LCOM labs are relatively small projects, thus executing make clean will not increase significantly the compilation time.

The second of these command lines, is especially useful to be able to take advantage of incremental compilation of the make utility. Usually, Makefiles define explicitly the dependencies on other source files and on libraries. However, they do not define explicitly the dependencies of header files. make depend fills this gap by automatically keeping track of the dependencies on header files. Thus the invocation of make after make depend will compile a source file only if:

either it has changed since the most recent time it was compiled
or it depends on a header file that has changed since the most recent time it was compiled.
Please note, that make may invoke not only the compiler but also other binary tools required to generate your program, according to a set of rules defined in the Makefile

6.2 Running
After compiling, you can execute your program using the lcom_run utility, as follows:

minix$ cd ~/labs/lab3
minix$ lcom_run lab3 ["<list of space separated arguments>"]
Note that the first command, is just to ensure that you execute lcom_run in a directory where it can find lab3.

Prev Top Next

Prev Top
7. Testing with the LCF
The LCF has a testing mode that allows you to test your code, by adding the string "-t <test no.>" at the end of the command line (as printed in the usage help message when you run lab3 via lcom_run, without specifying any argument).

In test mode, the LCF checks if your program behaves as expected; in other words, if the output is provided when and as expected. In this mode, the LCF itself generates the scancodes, thus emulating the keyboard and the user that types on the keyboard. Please note that the LCF does not try to emulate a human user, instead the scancode bytes are "sent" in quick succession, thus its temporal behavior is not what you would observe if a human user was using the keyboard.

Before exiting, the LCF prints a message with the result of the test, either "Test FAILED" or "Test succeeded". Furthermore, it prints the sequence of scancode bytes injected, after the line with the test outcome. The value of these bytes are represented in hexadecimal, but they are not prefixed with "0x". This is intended to help debugging, if needed.

IMP.- The LCF tests for this lab only check the behavior of your program. Therefore, you may implement any of the functions without following the specifications, e.g. using interrupts instead of polling, in kbd_test_poll(), and your program may still pass the tests.

In test mode, the LCF generates only 1-byte scancodes. To test your code for 2-byte scancodes, you will have to type on the keyboard.

IMP.- To manually test the code you develop in this lab, you need to type on the VM's keyboard, rather than on a remote shell.

Remember that in test mode, the trace and output log functionalities of the LCF are disabled. Nevertheless, you can still use printf() and check its output in the /var/log/messages file.

7.1 Testing kbd_test_scan() and kbd_test_poll()
The value of <test no.>, must be one of 0 to 5, for both functions.

When <test no.> is different from 0, the LCF will behave deterministically, i.e. it will generate always the same (relatively short) sequence of scancodes that always terminates with the makecode and the breakcode of the ESC key.

We suggest that you execute the tests "in order", starting with test no. 1 and up to test no.5. You should run test no. 0 only after running each of the other tests a few times.

Test no. 1 just tests if your code handles properly the ESC key. Test no. 5 issues a sequence of 5 keys (followed by the ESC key). Note that test no. 5 is the only test that checks whether your program computes correctly the number of sys_inb() calls.

The purpose of test number 0 is to allow you to more extensively test your code. Thus, the LCF will generate a sequence of random make code and break code pairs. Some of these codes may not correspond to any keyboard key. The length of this sequence is also random.

7.2 Testing kbd_test_timed_scan(uint8_t idle)
For this function, the value of <test no.>, must be one of 0 to 10.

When <test no.> is different from 0, the LCF will behave deterministically, i.e. it will generate always the same (relatively short) sequence of scancodes.

Test nos. from 1 to 5 are similar to those of the other functions. Actually, they inject exactly the same scancodes as the test cases with the same number of kbd_test_scan() or kbd_test_poll(), and your program is expected to terminate upon reading the breakcode of the ESC key.

Test nos. from 6 to 10 test whether your program terminates when the keyboard is idle for the time interval specified. These tests inject exactly the same sequence of tests 1 to 5, respectively, except for the last two scancodes, the ESC key's make and break codes, which are never injected.

Test no. 0 works similarly as for the other functions, except that he injection of the ESC scancodes is also random. Therefore, to pass the test, sometimes your program must exit after <idle> seconds, whereas other times it must exit upon receiving ESC key's break code.

Prev Top

